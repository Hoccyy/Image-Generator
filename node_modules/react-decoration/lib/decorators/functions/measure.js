'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = measure;

var _validators = require('../../utils/validators');

var getPerf = function getPerf() {
  return {
    time: performance && performance.now ? performance.now() : 0,
    memory: performance && performance.memory ? performance.memory : {
      jsHeapSizeLimit: 0,
      totalJSHeapSize: 0,
      usedJSHeapSize: 0
    }
  };
};

//eslint-disable-next-line
function measure() {
  var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : console.log;

  return function (target, key, descriptor) {
    var userFunc = descriptor.value;
    (0, _validators.validateFunction)(userFunc, 'measure');

    return _extends({}, descriptor, {
      value: function measurer() {
        var before = getPerf();

        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }

        var result = userFunc.apply(this, [].concat(params));
        var after = getPerf();
        callback({
          before: before,
          after: after,
          comparison: {
            time: after.time - before.time,
            memory: {
              usedJSHeapSize: after.memory.usedJSHeapSize - before.memory.usedJSHeapSize
            }
          }
        });
        return result;
      }
    });
  };
}